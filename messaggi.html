<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Messaggi - BackTag</title>
  <style>
    body{font-family:Arial,sans-serif;background:#fefaf6;color:#111;margin:0;padding:30px 16px;text-align:center}
    .logo{width:300px;margin-bottom:10px}
    h1{font-size:24px;margin:6px 0 16px}
    .meta{color:#555;font-size:14px;margin-bottom:16px}
    .thread{max-width:640px;margin:0 auto 16px;padding:16px;background:#fff9f0;border-radius:16px;box-shadow:0 8px 20px rgba(0,0,0,.05);text-align:left;min-height:180px}
    .msg{padding:10px 12px;border-radius:10px;margin-bottom:10px}
    .from-finder{background:#f0e6d5}
    .from-owner{background:#d3b277;color:#fff;text-align:right}
    .ts{font-size:12px;color:#444;opacity:.8;margin-top:4px}
    .composer{max-width:640px;margin:0 auto}
    textarea{width:100%;max-width:640px;height:110px;padding:14px;font-size:16px;border:1px solid #ccc;border-radius:10px;box-sizing:border-box;margin-bottom:10px}
    button{background:#a6947c;color:#fff;border:none;padding:12px 22px;font-size:16px;border-radius:10px;cursor:pointer}
    .back{margin-top:16px;font-size:14px;display:inline-block}
  </style>
</head>
<body>
  <img src="logo-backtag.png" alt="Logo BackTag" class="logo" />
  <h1>Messaggi</h1>
  <div class="meta" id="meta"></div>

  <div class="thread" id="thread">Caricamento…</div>

  <div class="composer">
    <textarea id="reply" placeholder="Scrivi una risposta al trovate…"></textarea><br>
    <button id="sendBtn">Invia risposta</button>
  </div>

  <a class="back" href="profilo.html">← Torna al profilo</a>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
    import {
      getFirestore, collection, query, where, orderBy, onSnapshot,
      addDoc, serverTimestamp, getDocs, updateDoc
    } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyD0kpQb-t5aJrMQ9mNnvJgl53Fe8UgPwrc",
      authDomain: "backtag-16de3.firebaseapp.com",
      projectId: "backtag-16de3",
      storageBucket: "backtag-16de3.appspot.com",
      messagingSenderId: "415455463905",
      appId: "1:415455463905:web:abd5e58bdeaaf6e3b9eaa0",
      measurementId: "G-6565LXTZW7"
    };
    const app = initializeApp(firebaseConfig);
    const db  = getFirestore(app);

    const params = new URLSearchParams(location.search);
    const codice = (params.get("code") || params.get("codice") || "").trim();
    const email  = localStorage.getItem("email") || "";

    const metaEl   = document.getElementById("meta");
    const threadEl = document.getElementById("thread");
    const replyEl  = document.getElementById("reply");
    const sendBtn  = document.getElementById("sendBtn");

    if (!codice || !email) {
      threadEl.textContent = "Dati mancanti.";
      sendBtn.disabled = true;
    } else {
      metaEl.textContent = `QR: ${codice}`;
      startThread();
    }

    // === CHAT REALTIME (schema nuovo: toEmail/dir/letto/ts) ===
    function startThread(){
      // tutti i messaggi per questo QR destinati a questo proprietario
      const qThread = query(
        collection(db,"messaggi"),
        where("codice","==", codice),
        where("toEmail","==", email),
        orderBy("ts","asc")
      );

      onSnapshot(qThread, async (snap)=>{
        // se non arriva nulla, prova in retro-compatibilità (schema vecchio)
        if (snap.empty) {
          renderFallback(); // NON bloccare, mostra comunque eventuali messaggi vecchi
        } else {
          await markIncomingAsRead(); // segna letti i non letti
          renderMessages(snap.docs.map(d=>d.data()));
        }
      });
    }

    // Marca come letti tutti i messaggi IN non letti (per far sparire il badge)
    async function markIncomingAsRead(){
      const qUnread = query(
        collection(db,"messaggi"),
        where("codice","==", codice),
        where("toEmail","==", email),
        where("dir","==","in"),
        where("letto","==", false)
      );
      const s = await getDocs(qUnread);
      await Promise.allSettled(s.docs.map(d => updateDoc(d.ref, { letto: true })));
    }

    // Invio risposta (schema nuovo)
    sendBtn.addEventListener("click", async ()=>{
      const testo = (replyEl.value || "").trim();
      if (!testo) return;
      await addDoc(collection(db,"messaggi"), {
        codice,
        toEmail: email,           // thread = (codice + proprietario)
        fromEmail: email,         // opzionale
        testo,
        dir: "out",               // messaggio in uscita dal proprietario
        letto: true,              // i tuoi messaggi sono già "letti"
        ts: serverTimestamp()
      });
      replyEl.value = "";
    });

    // Render lista messaggi (schema nuovo)
    function renderMessages(list){
      if (!list.length) {
        threadEl.textContent = "Nessun messaggio ancora.";
        return;
      }
      threadEl.innerHTML = "";
      list.forEach(m=>{
        const div = document.createElement("div");
        const fromOwner = m.dir === "out"; // in = finder → sinistra, out = owner → destra
        div.className = "msg " + (fromOwner ? "from-owner" : "from-finder");
        const when = m.ts?.toDate ? m.ts.toDate().toLocaleString() : "";
        div.innerHTML = `<div>${escapeHtml(m.testo || "")}</div>${when?`<div class="ts">${when}</div>`:""}`;
        threadEl.appendChild(div);
      });
      threadEl.scrollTop = threadEl.scrollHeight;
    }

    // === FALLBACK per vecchi documenti (email/from/read/data) ===
    async function renderFallback(){
      try{
        const qOld = query(
          collection(db,"messaggi"),
          where("email","==", email),
          where("codice","==", codice),
          orderBy("data","asc")
        );
        const s = await getDocs(qOld);
        if (s.empty){
          threadEl.textContent = "Nessun messaggio ancora.";
          return;
        }
        // segna come letti (vecchio schema)
        await Promise.allSettled(
          s.docs.filter(d => d.data().read === false)
                .map(d => updateDoc(d.ref, { read: true }))
        );
        // render
        const list = s.docs.map(d => d.data()).map(m => ({
          testo: m.testo,
          dir: (m.from === "owner" ? "out" : "in"),
          ts: m.data
        }));
        renderMessages(list);
      }catch(e){
        threadEl.textContent = "Errore nel caricamento.";
        console.error(e);
      }
    }

    // utilità semplice anti-HTML injection
    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, c => (
        { "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[c]
      ));
    }
  </script>
</body>
</html>
